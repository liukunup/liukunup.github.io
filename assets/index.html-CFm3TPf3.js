import{_ as o,c as r,d as n,o as t}from"./app-BxVB_gzI.js";const i={};function a(l,e){return t(),r("div",null,[...e[0]||(e[0]=[n('<h2 id="ai-coding-tools" tabindex="-1"><a class="header-anchor" href="#ai-coding-tools"><span>AI Coding Tools</span></a></h2><h3 id="claude-code" tabindex="-1"><a class="header-anchor" href="#claude-code"><span>Claude Code</span></a></h3><ul><li><strong>简介</strong>: Anthropic 推出的官方命令行 AI 编码助手，深度集成了 Claude 3.5 Sonnet/Opus 模型。它能够直接在终端中理解项目上下文、执行文件操作并生成代码。</li><li><strong>最佳实践</strong>: <ul><li>利用其强大的推理能力处理复杂的重构任务。</li><li>使用 <code>claude</code> 命令配合文件路径（如 <code>claude src/</code>）一次性加载相关上下文。</li></ul></li><li><strong>链接</strong>: <a href="https://www.anthropic.com" target="_blank" rel="noopener noreferrer">Anthropic</a></li></ul><h3 id="claude-code-router" tabindex="-1"><a class="header-anchor" href="#claude-code-router"><span>Claude Code Router</span></a></h3><ul><li><strong>简介</strong>: 一个智能路由工具，用于在 Claude 的不同模型（Haiku, Sonnet, Opus）之间自动分配编码任务。它根据任务的复杂度（如简单修复 vs 架构设计）选择性价比最高的模型。</li><li><strong>最佳实践</strong>: <ul><li>配置路由规则：将文档修正路由至 Haiku，逻辑开发路由至 Sonnet，复杂架构路由至 Opus。</li></ul></li><li><strong>链接</strong>: (社区工具或概念)</li></ul><h3 id="openai-codex" tabindex="-1"><a class="header-anchor" href="#openai-codex"><span>OpenAI Codex</span></a></h3><ul><li><strong>简介</strong>: OpenAI 专为代码生成训练的大语言模型，是 GitHub Copilot 的早期基础。现在主要指通过 OpenAI API 直接访问的代码能力（如 GPT-4o）。</li><li><strong>最佳实践</strong>: <ul><li>在 Playground 中测试复杂的 Prompt 逻辑，确认模型生成的代码片段准确性后再集成。</li></ul></li><li><strong>链接</strong>: <a href="https://platform.openai.com/docs/guides/code" target="_blank" rel="noopener noreferrer">OpenAI Platform</a></li></ul><h3 id="github-copilot" tabindex="-1"><a class="header-anchor" href="#github-copilot"><span>GitHub Copilot</span></a></h3><ul><li><strong>简介</strong>: 业界最成熟的 AI 结对程序员，集成在 VS Code 等 IDE 中，提供代码补全、聊天和内联建议。</li><li><strong>最佳实践</strong>: <ul><li><strong>注释驱动开发</strong>: 先写详细的注释或函数签名，让 Copilot 填充实现。</li><li><strong>Copilot Workspace</strong>: 利用 Copilot Workspace 进行跨文件的复杂任务规划。</li></ul></li><li><strong>链接</strong>: <a href="https://github.com/features/copilot" target="_blank" rel="noopener noreferrer">GitHub Copilot</a></li></ul><h3 id="gemini-cli" tabindex="-1"><a class="header-anchor" href="#gemini-cli"><span>Gemini CLI</span></a></h3><ul><li><strong>简介</strong>: Google Gemini 模型的命令行接口。凭借 Gemini 1.5 Pro 的超长上下文窗口（2M+ tokens），它可以一次性读取并理解整个大型代码库。</li><li><strong>最佳实践</strong>: <ul><li><strong>全库审计</strong>: 将整个 <code>src/</code> 目录作为上下文，询问全局性的架构问题或进行 Bug 追踪。</li><li>使用 Google AI Studio 获取 API Key 并配置 CLI。</li></ul></li><li><strong>链接</strong>: <a href="https://aistudio.google.com/" target="_blank" rel="noopener noreferrer">Google AI Studio</a></li></ul><h3 id="amp" tabindex="-1"><a class="header-anchor" href="#amp"><span>Amp</span></a></h3><ul><li><strong>简介</strong>: 一款新颖的 AI 驱动的代码编辑器/工具，强调速度和键盘操作，通过 AI 预测开发者的下一个意图。（注：也可能指 Rust 编写的终端编辑器 Amp，但在 AI Coding 语境下通常指 AI 增强版）。</li><li><strong>最佳实践</strong>: <ul><li>结合 Vim 模式使用，利用 AI 快速生成样板代码。</li></ul></li><li><strong>链接</strong>: <a href="https://amp.rs/" target="_blank" rel="noopener noreferrer">Amp Editor</a> (参考)</li></ul><h3 id="cursor-agent-cli" tabindex="-1"><a class="header-anchor" href="#cursor-agent-cli"><span>Cursor Agent CLI</span></a></h3><ul><li><strong>简介</strong>: Cursor 编辑器的无头（Headless）CLI 版本。允许在服务器或 CI/CD 环境中运行 Cursor 的 &quot;Composer&quot; Agent 功能，自动修改代码。</li><li><strong>最佳实践</strong>: <ul><li>在 CI 流水线中集成，用于自动修复 Lint 错误或根据 TODO 注释自动生成代码。</li></ul></li><li><strong>链接</strong>: <a href="https://cursor.sh" target="_blank" rel="noopener noreferrer">Cursor</a></li></ul><h3 id="opencode" tabindex="-1"><a class="header-anchor" href="#opencode"><span>OpenCode</span></a></h3><ul><li><strong>简介</strong>: 一个开放的 AI 编程环境标准或平台，旨在定义 AI Agent 与代码库交互的接口。</li><li><strong>最佳实践</strong>: <ul><li>遵循 OpenCode 协议编写自定义 Agent，确保跨工具的兼容性。</li></ul></li><li><strong>链接</strong>: (相关项目: <a href="https://github.com/google-deepmind/open_code_interpreter" target="_blank" rel="noopener noreferrer">OpenCode Interpreter</a>)</li></ul><h3 id="factory-droid" tabindex="-1"><a class="header-anchor" href="#factory-droid"><span>Factory Droid</span></a></h3><ul><li><strong>简介</strong>: 一个专注于批量化代码生成和自动化维护的 AI Agent。它像工厂流水线一样，根据蓝图（Blueprints）批量生产模块代码。</li><li><strong>最佳实践</strong>: <ul><li>定义清晰的模板（Blueprints），用于生成 CRUD 接口或测试用例。</li></ul></li><li><strong>链接</strong>: (无特定官方链接，概念性工具)</li></ul><h3 id="qwen-code" tabindex="-1"><a class="header-anchor" href="#qwen-code"><span>Qwen Code</span></a></h3><ul><li><strong>简介</strong>: 阿里巴巴通义千问团队推出的代码专用模型（Qwen2.5-Coder）。在多语言支持和数学逻辑方面表现出色，开源且性能强大。</li><li><strong>最佳实践</strong>: <ul><li>部署本地版 Qwen-Coder 配合 Ollama 使用，保护代码隐私。</li></ul></li><li><strong>链接</strong>: <a href="https://github.com/QwenLM/Qwen" target="_blank" rel="noopener noreferrer">Qwen GitHub</a></li></ul><h2 id="agent-orchestration-vibe-coding" tabindex="-1"><a class="header-anchor" href="#agent-orchestration-vibe-coding"><span>Agent Orchestration (Vibe Coding)</span></a></h2><h3 id="vibe-kanban" tabindex="-1"><a class="header-anchor" href="#vibe-kanban"><span>Vibe Kanban</span></a></h3><ul><li><strong>简介</strong>: <a href="https://www.vibekanban.com/" target="_blank" rel="noopener noreferrer">Vibe Kanban</a> 是一个并行的 AI 编码代理编排工具。它使用 Git worktrees 为每个 AI Agent（Claude, Codex 等）提供独立工作区，允许开发者像看板一样管理多个 AI 的并发任务。</li><li><strong>最佳实践</strong>: <ul><li><strong>并发开发</strong>: 同时指派一个 Agent 写前端组件，另一个 Agent 写后端 API。</li><li><strong>Code Review</strong>: 使用内置 Diff 工具，像审查人类代码一样审查 Agent 的产出。</li></ul></li><li><strong>链接</strong>: <a href="https://www.vibekanban.com/docs" target="_blank" rel="noopener noreferrer">官方文档</a></li></ul><h3 id="oh-my-opencode" tabindex="-1"><a class="header-anchor" href="#oh-my-opencode"><span>Oh My OpenCode</span></a></h3><ul><li><strong>简介</strong>: <a href="https://github.com/code-yeongyu/oh-my-opencode" target="_blank" rel="noopener noreferrer">Oh My OpenCode</a> 是一个功能强大的 OpenCode 代理编排插件。核心代理 <strong>Sisyphus</strong> 能自动拆解任务，调度 Oracle（架构）、Librarian（文档）、Frontend（前端）等子代理协同工作。</li><li><strong>最佳实践</strong>: <ul><li><strong>Ultrawork 模式</strong>: 使用 <code>ultrawork</code> 命令开启全自动循环开发，适合从零构建功能模块。</li><li><strong>LSP 辅助</strong>: 确保环境中有对应的 Language Server，以便 Agent 能准确跳转和重构。</li></ul></li><li><strong>链接</strong>: <a href="https://github.com/code-yeongyu/oh-my-opencode" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><h3 id="stitch-ai-studio" tabindex="-1"><a class="header-anchor" href="#stitch-ai-studio"><span>Stitch &amp; AI Studio</span></a></h3><ul><li><strong>简介</strong>: 结合 <strong>Google AI Studio</strong> 的强大原型能力与代码&quot;缝合&quot;（Stitch）工具。利用 AI Studio 的快速 Prompt 调试和多模态输入，生成代码片段，再通过 Stitch 工具将其集成到现有项目中。</li><li><strong>最佳实践</strong>: <ul><li>在 AI Studio 中上传 UI 截图，生成前端代码，然后&quot;缝合&quot;到 React 组件中。</li></ul></li><li><strong>链接</strong>: <a href="https://aistudio.google.com/" target="_blank" rel="noopener noreferrer">Google AI Studio</a></li></ul>',28)])])}const g=o(i,[["render",a]]),d=JSON.parse('{"path":"/notes/vibe-coding/best-practice/","title":"最佳实践","lang":"zh-CN","frontmatter":{"title":"最佳实践","tags":["ai coding"],"createTime":"2026/01/11 17:21:02","permalink":"/notes/vibe-coding/best-practice/"},"readingTime":{"minutes":4.24,"words":1272},"git":{"createdTime":1768200389000,"updatedTime":1768200389000,"contributors":[{"name":"LiuKun","username":"LiuKun","email":"liukunup@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/LiuKun?v=4","url":"https://github.com/LiuKun"}]},"filePathRelative":"notes/Vibe Coding/最佳实践.md","headers":[]}');export{g as comp,d as data};
